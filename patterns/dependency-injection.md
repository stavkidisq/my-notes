### Dependency Injection - внедрение зависимостей.

Ниже представлено определение из сайта *Wikipedia*.

> *Внедрение зависимости (англ. Dependency Injection, DI)* - процесс предоставления внешней зависимости программному компоненту. Является специфичной формой 
"инверсии управления" (*Invertion of Control, IoC*), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной обязанности
объект отдает заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

#### Внедрение зависимостей.

Внедрение зависимостей - это метод, широко используемый в программировании и хорошо подходящий для разработки приложений. Следуя принципам Dependency Injection, вы 
закладываете основу хорошей архитектуры приложения.

Dependency Injection имеет следующие преимущества:
- Возможность повторного использования кода.
- Легкость рефакторинга.
- Легкость тестирования.

#### Внедрение зависимостей. Основы.

Например, у нас есть два класса: `Car` и `Engine`. Классу `Car` может потребоваться ссылка на `Engine`. В данном случае класс `Engine` является обязательным условием существования класса `Car`, следовательно класс `Car` зависит от `Engine`. Данное отношение классов называется *зависимостью*.

У нашего класса есть три способа для получения нашего объекта:
- Класс конструирует нужную ему зависимость.
- Перехват его от других источников.
- Указание класса, как параметр. Приложение может предоставить эти зависимости при создании класса или передать их функциям, которым нужна каждая зависимость. В данном случае, конструктор класса `Car` получит `Engine` в качестве параметра.

Третий способ является внедрением зависимостей. При таком подходе вы берете зависимости класса и предоставляете их, а не позволяете экземпляру класса получать их самому.

Ниже представлен пример, когда Dependency Injection не выполняется

```csharp
public class Car
{
  private Engine Engine { get; set; } = new Engine();
  
  public void Start()
  {
    Engine.Start();
  }
}

// main()

var car = new Car();
car.Start();
```

В данном примере мы позволили классу `Car` самостоятельно создать экземпляр объекта внутри себя, что подходит к первому способу получения объекта `Engine`. Однако данный класс имеет ряд проблем, одной из который является жесткая зависимость класса `Car` от `Engine`. Данная проблема осложнит тестирование кода. Еще одной проблемой является расширяемость кода. Например, мы захотели создать группу родственных классу `Engine` объектов (`ElectricEngine`, `GasEngine` и т.д.), однако тогда прийдется создавать экземпляры двух типов, что не есть хорошо.

Наконец настало время для написания примера того самого *Dependency Injection*.

```csharp
public class Car
{
  private Engine Engine { get; set; }
  
  public Car(Engine engine)
  {
    Engine = engine;
  }
  
  public void Start()
  {
    Engine.Start();
  }
}

// main()

var engine = new Engine();
var car = new Car(engine);
car.Start();
```

Теперь, с помощью *Dependency Injection* все проблемы, которые были в первом примере, решились
- Зависимость класса `Car` от класса `Engine` перестала быть жесткой.
- Код стал доступным для расширения. Чтобы организовать группу классов `Engine`, необходимо просто создать их объекты, а также унаследовать их от `Engine` и засунуть внутрь конструктора класса `Car`.

#### Паттерны внедрения зависимостей.

Самыми необходимыми и базовыми паттернами *Dependency Injection*, которые необходимо знать для написания более качественного и гибкого кода являются:
- **Cunstructor Injection** - внедрение конструкторов.
- **Property Injection** - внедрение свойств.

Рассмотрим приведенные выше паттерны более подробно и начнем с самого первого - Cunstructor Injection.

##### Constructor Injection - внедрение конструктора.

*Назначение*: разорвать жесткую связь между классом и его обязательными *зависимостями*.
*Описание*: все зависимости, требуемые некоторому классу передаются ему в качестве параметров конструктора, представленных в виде интерфейсов или абстрактных классов.
*Задача*: как гарантировать, что требуемая зависимость будет всегда доступна разрабатываему классу?
*Решение*: все вызывающие классы будут передавать зависимость как параметр конструктора.

```csharp
private readonly IFoo _foo; // readonly - хорошая практика

/* Всегда должен быть обязятельным и открытым */
public Foo(IFoo foo)
{
  _foo = throw new ArgumentNullException(nameof(foo)) ?? foo;
}
```

Также хотелось бы привести несколько объяснений данного кода
- Зависимость является обязательным аргументом конструктора.
- Код любого клиента, который не предоставляет экземпляра зависимости, не может компилироваться.
- Конструктор класса должен быть открытым.
- Ключевое слово `readonly` переменной интерфейса `IFoo` является хорошей практикой.

*Использование*: внедрение через конструктор должно по умолчанию использоваться с внедрением зависимостей. Оно реализует наиболее популярный сценарий, когда классу нужны одна или более зависимостей, а в наличии не имеется подходящих локальных умолчаний.

Ниже представлены наиболее лучшие советы и практики по использованию внедрения через конструктор
- В идеале нужно ограничивать класс одним конструктором.
- В конструкторе не должно быть никакой другой логики.
- Зависимость больше не требуется проверять на `null`, так как это уже сделал конструктор.

Достоинства паттерна внедрения через конструктор:
- Внедрение гарантировано.
- Простота реализации.
- Обеспечение четкого контракта между классом и его элементами.
- Сложность класса становится очевидной.

Недостатки паттерна внедрения зависимостей:
- В некторые фреймворки сложно задействовать внедрение зависимостей через конструктор.
- Требование немедленной инициализации всего графа зависимости. Может привести к снижению производительности системы, однако в платформе .NET это очень редкое явление.

Одной из важных проблем, которые могут произойти при использовании внедрения зависимостей через конструктор - это перенасыщение конструктора параметрами.
