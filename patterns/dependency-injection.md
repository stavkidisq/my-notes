### Dependency Injection - внедрение зависимостей.

Ниже представлено определение из сайта *Wikipedia*.

> *Внедрение зависимости (англ. Dependency Injection, DI)* - процесс предоставления внешней зависимости программному компоненту. Является специфичной формой 
"инверсии управления" (*Invertion of Control, IoC*), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной обязанности
объект отдает заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

#### Внедрение зависимостей.

Внедрение зависимостей - это метод, широко используемый в программировании и хорошо подходящий для разработки приложений. Следуя принципам Dependency Injection, вы 
закладываете основу хорошей архитектуры приложения.

Dependency Injection имеет следующие преимущества:
- Возможность повторного использования кода.
- Легкость рефакторинга.
- Легкость тестирования.

#### Внедрение зависимостей. Основы.

Например, у нас есть два класса: `Car` и `Engine`. Классу `Car` может потребоваться ссылка на `Engine`. В данном случае класс `Engine` является обязательным условием существования класса `Car`, следовательно класс `Car` зависит от `Engine`. Данное отношение классов называется *зависимостью*.

У нашего класса есть три способа для получения нашего объекта:
- Класс конструирует нужную ему зависимость.
- Перехват его от других источников.
- Указание класса, как параметр. Приложение может предоставить эти зависимости при создании класса или передать их функциям, которым нужна каждая зависимость. В данном случае, конструктор класса `Car` получит `Engine` в качестве параметра.

Третий способ является внедрением зависимостей. При таком подходе вы берете зависимости класса и предоставляете их, а не позволяете экземпляру класса получать их самому.

Ниже представлен пример, когда Dependency Injection не выполняется

```csharp
public class Car
{
  private Engine Engine { get; set; } = new Engine();
  
  public void Start()
  {
    Engine.Start();
  }
}

// main()

var car = new Car();
car.Start();
```

В данном примере мы позволили классу `Car` самостоятельно создать экземпляр объекта внутри себя, что подходит к первому способу получения объекта `Engine`. Однако данный класс имеет ряд проблем, одной из который является жесткая зависимость класса `Car` от `Engine`. Данная проблема осложнит тестирование кода. Еще одной проблемой является расширяемость кода. Например, мы захотели создать группу родственных классу `Engine` объектов (`ElectricEngine`, `GasEngine` и т.д.), однако тогда прийдется создавать экземпляры двух типов, что не есть хорошо.

Наконец настало время для написания примера того самого *Dependency Injection*.

```csharp
public class Car
{
  private Engine Engine { get; set; }
  
  public Car(Engine engine)
  {
    Engine = engine;
  }
  
  public void Start()
  {
    Engine.Start();
  }
}

// main()

var engine = new Engine();
var car = new Car(engine);
car.Start();
```

Теперь, с помощью *Dependency Injection* все проблемы, которые были в первом примере, решились
- Зависимость класса `Car` от класса `Engine` перестала быть жесткой.
- Код стал доступным для расширения. Чтобы организовать группу классов `Engine`, необходимо просто создать их объекты, а также унаследовать их от `Engine` и засунуть внутрь конструктора класса `Car`.

#### Паттерны внедрения зависимостей.

Самыми необходимыми и базовыми паттернами *Dependency Injection*, которые необходимо знать для написания более качественного и гибкого кода являются:
- **Cunstructor Injection** - внедрение конструкторов.
- **Property Injection** - внедрение свойств.

Рассмотрим приведенные выше паттерны более подробно и начнем с самого первого - Cunstructor Injection.

##### Constructor Injection - внедрение конструктора.

*Назначение*: разорвать жесткую связь между классом и его обязательными *зависимостями*.
*Описание*: все зависимости, требуемые некоторому классу передаются ему в качестве параметров конструктора, представленных в виде интерфейсов или абстрактных классов.
*Задача*: как гарантировать, что требуемая зависимость будет всегда доступна разрабатываему классу?
*Решение*: все вызывающие классы будут передавать зависимость как параметр конструктора.

```csharp
private readonly IFoo _foo; // readonly - хорошая практика

/* Всегда должен быть обязятельным и открытым */
public Foo(IFoo foo)
{
  _foo = throw new ArgumentNullException(nameof(foo)) ?? foo;
}
```

Также хотелось бы привести несколько объяснений данного кода
- Зависимость является обязательным аргументом конструктора.
- Код любого клиента, который не предоставляет экземпляра зависимости, не может компилироваться.
- Конструктор класса должен быть открытым.
- Ключевое слово `readonly` переменной интерфейса `IFoo` является хорошей практикой.

*Использование*: внедрение через конструктор должно по умолчанию использоваться с внедрением зависимостей. Оно реализует наиболее популярный сценарий, когда классу нужны одна или более зависимостей, а в наличии не имеется подходящих локальных умолчаний.

Ниже представлены наиболее лучшие советы и практики по использованию внедрения через конструктор
- В идеале нужно ограничивать класс одним конструктором.
- В конструкторе не должно быть никакой другой логики.
- Зависимость больше не требуется проверять на `null`, так как это уже сделал конструктор.

Достоинства паттерна внедрения через конструктор:
- Внедрение гарантировано.
- Простота реализации.
- Обеспечение четкого контракта между классом и его элементами.
- Сложность класса становится очевидной.

Недостатки паттерна внедрения зависимостей:
- В некторые фреймворки сложно задействовать внедрение зависимостей через конструктор.
- Требование немедленной инициализации всего графа зависимости. Может привести к снижению производительности системы, однако в платформе .NET это очень редкое явление.

Одной из важных проблем, которые могут произойти при использовании внедрения зависимостей через конструктор - это перенасыщение конструктора параметрами.

##### Property Injecton - внедрение через свойство.

*Назначение*: разорвать жесткую связь между классом и его необязательными зависимостями.

*Задача*: как можно решить внедрение зависимостей как опцию в классе, если имеется подходящее локальное умолчание?
*Решение*: использованием записываемого свойства, что позволяет вызывающей стороне устанавливать его значение, если она хочет заменить поведение, применяемое по умолчанию.

Класс использующий зависимость должен быть открытым

```csharp
public class SomeClass
{
  public ISomeInterface Dependency { get; set; }
}
```

В данном коде класс `SomeClass` зависит от интерфейса `ISomeInterface`. Клиенты могут передавать реализацию `ISomeInterface` через свойство Dependency. Данное свойство может меняться во время жизненного пути `SomeClass`. Данное свойство может использоваться функциями `SomeClass`

```csharp
public string DoSomething(string message)
{
  return this.Dependency.DoStuff(message);
}
```

Однако приведенный ниже код не может гарантировать нам отсутствие `NullReferenceException`. Воспользовавшись следующим кодом, программа выдаст исключение.

```csharp
var sc = new SomeClass();
sc.DoSomething("Hello World!");
```

Чтобы избавиться от нависшей над нами проблемы, нужно осуществить внутри свойства проверку на значение `null`.

```csharp
public class SomeClass
{
  private ISomeInterface _dependency;
  
  public ISomeInterface Dependency 
  {
    get => _dependency;
    set => _dependency = value ?? throw new ArgumentNullException(nameof(value));
  }
  
  public SomeClass()
  {
    _dependency = new DefaultSomeInterface();
  }
}
```

*Задача*: Что должно произойти, если клиент попытается изменить значение зависимости в течение жизненного цикла класса?
*Решение*: следствием этого может быть противоречивое или неожиданное поведение класса, поэтому лучше защититься от этого следующим способом.

```csharp
public class SomeClass
{
  private ISomeInterface _dependency;
  
  public ISomeInterface Dependency
  {
    get => _dependency ?? (_dependency = new DefaultSomeInterface());
    set
    {
      if(_dependency != null)
        throw new InvalidOperationException(nameof(value));
        
      _dependency = value ?? throw new ArgumentNullException(nameof(value));
    }
  }
}
```

Первый блок сеттера отвечает за то, что значение зависимости можно установить только один раз. Следующий защитный блок защищает нас от установки значения `null`.

*Применение*: внедрение свойства следует применять только в случае, когда для разрабатываемого класса имеется подходящее локальное умолчание, но при этом вы хотели бы оставить вызывающей стороне возможность использовать другую реализацию типа зависимости.

Ошибки в использовании внедрения через свойства:
- Использование Property Injection для обязательных зависимостей.
- Сложность.
- //TODO:

Альтернативой использования Property Injection может стать старый подход с двумя конструкторами.

```csharp
public class SomeClass
{
  private ISomeInterface _dependency;
  
  public SomeClass() : this(new DefaultSomeInterface()) { }
  
  public SomeClass(ISomeInterface dependency)
  {
    _dependency = dependency;
  }
}
```
*Вывод*: паттерн внедрения зависимостей Property Injection идеально подходит для необязательных зависимостей.

#### DI-container.

Dependency Injection (DI) Contaier - это инструмент, который может решать (resolve) зависимости для их внедрения. Говоря простыми словами, это "черный ящик", в котором можно зарегистрировать классы (интерфейсы и их реализации) для дальнейшего их решения (resolve) в нужных местах, например в конструкторах.

Для чего нужен DI-контейнер:
- Создание экземпляров обхектов, то есть решение зависимостей, в том числе и иерархических.
- Управление жизненным циклов объектов (lifetime).
- Доступ из "любого" места в программе, практически в любом конструкторе.
