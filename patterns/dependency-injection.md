### Dependency Injection - внедрение зависимостей.

Ниже представлено определение из сайта *Wikipedia*.

> *Внедрение зависимости (англ. Dependency Injection, DI)* - процесс предоставления внешней зависимости программному компоненту. Является специфичной формой 
"инверсии управления" (*Invertion of Control, IoC*), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной обязанности
объект отдает заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

#### Внедрение зависимостей.

Внедрение зависимостей - это метод, широко используемый в программировании и хорошо подходящий для разработки приложений. Следуя принципам Dependency Injection, вы 
закладываете основу хорошей архитектуры приложения.

Dependency Injection имеет следующие преимущества:
- Возможность повторного использования кода.
- Легкость рефакторинга.
- Легкость тестирования.

#### Внедрение зависимостей. Основы.

Например, у нас есть два класса: `Car` и `Engine`. Классу `Car` может потребоваться ссылка на `Engine`. В данном случае класс `Engine` является обязательным условием существования класса `Car`, следовательно класс `Car` зависит от `Engine`. Данное отношение классов называется *зависимостью*.

У нашего класса есть три способа для получения нашего объекта:
- Класс конструирует нужную ему зависимость.
- Перехват его от других источников.
- Указание класса, как параметр. Приложение может предоставить эти зависимости при создании класса или передать их функциям, которым нужна каждая зависимость. В данном случае, конструктор класса `Car` получит `Engine` в качестве параметра.

Третий способ является внедрением зависимостей. При таком подходе вы берете зависимости класса и предоставляете их, а не позволяете экземпляру класса получать их самому.

Ниже представлен пример, когда Dependency Injection не выполняется

```csharp
public class Car
{
  private Engine Engine { get; set; } = new Engine();
  
  public void Start()
  {
    Engine.Start();
  }
}

// main()

var car = new Car();
car.Start();
```

В данном примере мы позволили классу `Car` самостоятельно создать экземпляр объекта внутри себя, что подходит к первому способу получения объекта `Engine`. Однако данный класс имеет ряд проблем, одной из который является жесткая зависимость класса `Car` от `Engine`. Данная проблема осложнит тестирование кода. Еще одной проблемой является расширяемость кода. Например, мы захотели создать группу родственных классу `Engine` объектов (`ElectricEngine`, `GasEngine` и т.д.), однако тогда прийдется создавать экземпляры двух типов, что не есть хорошо.

Наконец настало время для написания примера того самого *Dependency Injection*.

```csharp
public class Car
{
  private Engine Engine { get; set; }
  
  public Car(Engine engine)
  {
    Engine = engine;
  }
  
  public void Start()
  {
    Engine.Start();
  }
}

// main()

var engine = new Engine();
var car = new Car(engine);
car.Start();
```

Теперь, с помощью *Dependency Injection* все проблемы, которые были в первом примере, решились
- Зависимость класса `Car` от класса `Engine` перестала быть жесткой.
- Код стал доступным для расширения. Чтобы организовать группу классов `Engine`, необходимо просто создать их объекты, а также унаследовать их от `Engine` и засунуть внутрь конструктора класса `Car`.
