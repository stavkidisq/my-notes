### Отношения между классами.

#### Наследование.

**Наслеование** является одной из основных парадигм ООП. Позволяет передать функционал от одного класса (родительского) к другому (наследнику). Наследование на языке C# выглядит так

```csharp
public class User
{
  public int Id { get; set; }
  public string Name { get; set; }
}

public class Manager : User
{
  public string Company { get; set; }
}
```

Наследование на UML выглядит так

![image](https://user-images.githubusercontent.com/57217014/196491324-bc847bd2-bafa-4b0e-b722-cf6b7e2b910e.png)

#### Реализация.

**Реализация** предполагает определение интерфейса и его описание в классах. Реализация на языке C# выглядит так

```csharp
public interface IMovable
{
  void Move();
}

public class Car : IMovable
{
  public void Move()
  {
    Console.WriteLine("Car is driving.");
  }
}
```

Реализация на UML выглядит так

![image](https://user-images.githubusercontent.com/57217014/196492952-cf40c87e-d269-40d6-af55-5ecfa9743c59.png)

#### Ассоциация

**Ассоциация** - это отношение, при котором объекты одного типа некоторым образом связаны с объектами другого типа. Например, объект так или иначе использует объект
другого класса или содержит его. Ассоциация на языке C# выгладит так

```csharp
public class Team { //... }

public class Player
{
  public Team Team { get; set; }
}
```

Ассоциация на UML выглядит так

![image](https://user-images.githubusercontent.com/57217014/196494932-9e6aed81-38f9-4ec7-89f9-90be4769593f.png)

Знаки рядом со стрелкой ("1" и звездочка) означают связь один ко многим. То есть одна команда может содержать несколько игроков.

Также можно привести пример из реальной жизни. Представим два объекта: преподаватель и указка. Указку может взять любой преподаватель, так как она лежит в лекционном зале. Данная указка может использоваться не только преподавателем, но и любым другим объектом. В данном случае ассоциируются два разных объекта с разными жизненными циклами.

#### Композиция

**Композиция** - вид зависимости, когда в момент создания одного объкта мы создаем другой объект. То есть, внутри конструктора первого класса, мы описываем создание объекта другого класса. Их жизненные циклы начинаются одновременно 
Композиция отражает отношение **HAS A**, то есть отношение "имеет". Композиция на языке C# выгладит так

```csharp
public class ElectricalEngine { //... }

public Car
{
  private ElectricalEngine Engine { get; set; }
  
  public Car(ElectricalEngine _carEngine)
  {
    Engine = _engine;
  }
}
```

Композиция на UML выглядит так

![image](https://user-images.githubusercontent.com/57217014/196496701-8ac5bca2-7b23-47d5-9dbf-0f9e252f0ffe.png)

Например, кафедра математики и университет. Кафедра без университета не нужна, как и университет без кафедр. То есть в момент создания университеты мы создаем кафедры. Иными словами, конструктор класса университет создает новые классы кафедр. Не передача, а именно создание.

#### Агрегация

**Агрегация** - это когда один объект не может жить и функционировать без другого, а другой без первого может. Жизненный цикл зависимого объекта начинается позже. Например, персонал без университета может сущестовать, а университет без персонала - нет. То есть, для того, чтобы создать объект университета, мы должны указать персонал, который будет работать в нем. Агрегация - это, когда в конструктор отправляется ряд уже созданных объектов.

Агрегация похожа на композицию, так как она тоже определяет отношение **HAS A**, однако это разные вещи. Агрегация на языке C# выглядит так

```csharp
public class Engine { //... }

public Car
{
  private Engine Engine { get; set; }
  
  public Car(ElectricalEngine _carEngine)
  {
    Engine = _engine;
  }
}
```

Агрегация на UML выглядит так

![image](https://user-images.githubusercontent.com/57217014/196497908-10bcac7c-8837-4231-9a3f-d3caf4b5ded4.png)

Здесь жизненный цикл класса двигателя не равен жизненному циклу класса машины. Также можно сказать, что данные классы равноправны. То есть при уничтожении одного класса, другой может существовать. Как правило объект, который содержится в другом классе, должен быть абстрактным или вообще являться интерфейсом.

